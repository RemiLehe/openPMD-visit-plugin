/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtOpenPMDFileFormat.C                           //
// ************************************************************************* //

#include <unistd.h>

#include <avtOpenPMDFileFormat.h>

#include <vector>
#include <stdlib.h>
#include <stdio.h>
#include <stdio.h>
#include <iostream>
#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkVertex.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>
#include <InvalidFilesException.h>
#include <InvalidTimeStepException.h>
#include <InvalidDBTypeException.h>

using     std::string;


// ****************************************************************************
//  Method: avtOpenPMDFileFormat constructor
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

avtOpenPMDFileFormat::avtOpenPMDFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    cerr << "avtOpenPMDFileFormat::avtOpenPMDFileFormat "  << filename << endl;

    // Boolean to check that the initialization has been done
    this->initialized = false;
}


// ****************************************************************************
//  Method: ~avtOpenPMDFileFormat Destructor
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
avtOpenPMDFileFormat::~avtOpenPMDFileFormat()
{
    cerr << "avtOpenPMDFileFormat::~avtOpenPMDFileFormat" << endl;
}


// ****************************************************************************
//  Method: Initialize
//
//  Initialization: the OpenPMD file is read and analyze
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::Initialize()
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::Initialize" << endl;
#endif
    if(!this->initialized)
    {
        // Activate verbose
        openPMDFile.SetVerbose(1);

        // Open the OpenPMD file
        openPMDFile.OpenFile(filename);

        // Scan the iterations
        openPMDFile.ScanIterations();

        // For each iteration, scan the fields
        openPMDFile.ScanFields();

        // For each iteration, scan the particle groups
        openPMDFile.ScanParticles();

        this->parallel = true;

        this->initialized = true;
    }
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

int
avtOpenPMDFileFormat::GetNTimesteps(void)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::GetNTimesteps" << endl;
#endif

    // If not initialized, initialize...
    if(!this->initialized)
        this->Initialize();

    // Get the number of time steps read in the OpenPMD file
    int NTimesteps = this->openPMDFile.GetNumberIterations();

    return NTimesteps;
    //return 1;
}

// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetCycles
//
//  Purpose:
//      Get all cycles in the OpenPMD file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::GetCycles(std::vector<int> &cycles)
{

    int cycle;

    // Shortcut pointer to the vector iterations
    vector<PMDIteration> * iterations = &(openPMDFile.iterations);

    // Loop over the iterations
    for (std::vector<PMDIteration>::iterator it = iterations->begin() ; it != iterations->end(); ++it)
    {
        cycle = atoi(it->name);

        // Store the cycles in the vector.
        cycles.push_back(cycle);
    }

}

// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetTime
//
//  Purpose:
//      Get all times in the OpenPMD file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::GetTimes(std::vector<double> &times)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::GetTimes" << endl;    
#endif
    // Shortcut pointer to the vector iterations
    vector<PMDIteration> * iterations = &(openPMDFile.iterations);

    // Loop over the iterations
    for (std::vector<PMDIteration>::iterator it = iterations->begin() ; it != iterations->end(); ++it)
    {
        // Store the times in the vector.
        times.push_back(it->time*it->timeUnitSI);
    }
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

void
avtOpenPMDFileFormat::FreeUpResources(void)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::FreeUpResources" << endl;
#endif
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

void
avtOpenPMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::PopulateDatabaseMetaData(timeState=" << timeState << ")" << endl;
#endif

    int i;
    char buffer[128];
    char bufferMeshName[128];

    // ________________________________________________________
    // FIELDS

    // Creation of the meshes and the scalars from the vector of field objects

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timeState].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        // We first create a new mesh for the current field
        // Each field has its own mesh
        avtMeshMetaData *mmd = new avtMeshMetaData;
        // Create the mesh name
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        strcat(buffer,"_mesh");
        mmd->name = buffer;
        // Spatial dimension
        mmd->spatialDimension = field->ndims;
        // Topological Dimension
        mmd->topologicalDimension = field->ndims;
        // Mesh type
        // Cartesian
        if (strcmp(field->geometry,"cartesian")==0)
        {
            mmd->meshType = AVT_RECTILINEAR_MESH;
        }
        // Curvilinear, thetaMode
        else if (strcmp(field->geometry,"thetaMode")==0)
        {
            mmd->meshType = AVT_CURVILINEAR_MESH;
        }

        // Number of blocks
        mmd->numBlocks = 4;
        // Add mesh
        md->Add(mmd);

        // Then we create a scalar for the current field
        avtScalarMetaData *smd = new avtScalarMetaData;
        // Create the variable name
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        smd->name = buffer;
        // And select the right mesh
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        strcat(buffer,"_mesh");
        smd->meshName = buffer;
        // Node or cell centered
        smd->centering = AVT_NODECENT;
        // Units
        smd->hasUnits = true;
        smd->units = field->unitsLabel;
        // Add the scalars
        md->Add(smd);

    }  

    // ________________________________________________________
    // PARTICLES

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timeState].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {

        // Add a point mesh to the metadata for the particles
        avtMeshMetaData *mmd = new avtMeshMetaData;
        // Mesh name
        strcpy(bufferMeshName,"Particles/");
        strcat(bufferMeshName,particle->name);
        strcat(bufferMeshName,"/position_mesh");
        mmd->name = bufferMeshName;
        // Spatial and topological dimension
        mmd->spatialDimension = 3;
        mmd->topologicalDimension = 0;
        // Type of mesh, here point mesh
        mmd->meshType = AVT_POINT_MESH;
        mmd->numBlocks = 1;
        md->Add(mmd);

        // We create a scalar metadata for each scalar in scalarDataSets
        for (i=0;i<particle->GetNumScalarDatasets();i++)
        {

            // Then we create a scalar for the current field
            avtScalarMetaData *smd = new avtScalarMetaData;
            // Create the scalar name
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->scalarDataSets[i].name);
            smd->name = buffer;

            // And select the right mesh
            smd->meshName = bufferMeshName;
            // Node or cell centered
            smd->centering = AVT_NODECENT;

            // Units
            smd->hasUnits = true;
            smd->units = particle->scalarDataSets[i].unitLabel;
            // Add the scalars
            md->Add(smd);

        }

        // We create a vector metadata for each scalar in scalarDataSets
        for (i=0;i<particle->GetNumVectorDatasets();i++)
        {
            avtVectorMetaData *vmd = new avtVectorMetaData;
            // Create the scalar name
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->vectorDataSets[i].name);
            vmd->name = buffer;
            // And select the right mesh
            vmd->meshName = bufferMeshName;
            // Node or cell centered
            vmd->centering = AVT_ZONECENT;
            // Units
            vmd->hasUnits = true;
            vmd->units = particle->vectorDataSets[i].unitLabel;
            // Vector dimension
            vmd->varDim = 3;
            md->Add(vmd);
        }  

        if (particle->momentumAvailable)
        {
            // Particle Expressions
            Expression *e1 = new Expression;
            // Create the name
            strcpy(buffer,"Particles/");  
            strcat(buffer,particle->name);
            strcat(buffer,"/gamma");
            e1->SetName(buffer);

            // Creation of the expression definition
            char definition[256];

            // If we have 3 momentum components
            if (particle->numDimsMomenta==3)
            {
                // Create the definition
                char px[128], py[128], pz[128];

                // Expression 
                sprintf(px,"Particles/%s/momentum/x",particle->name);
                sprintf(py,"Particles/%s/momentum/y",particle->name);
                sprintf(pz,"Particles/%s/momentum/z",particle->name);        

                sprintf(definition,"sqrt(1.0+(<%s>^2+<%s>^2+<%s>^2)/(299792458*%e)^2)",px,py,pz,particle->mass);
            }
            // If we have only two momentum components, we suppose that the dimension is 2
            else if (particle->numDimsMomenta==2)
            {
                // Create the definition
                char px[128], pz[128];

                // Expression: this is only valid if z is the main direction
                sprintf(px,"Particles/%s/momentum/x",particle->name);
                sprintf(pz,"Particles/%s/momentum/z",particle->name);        

                sprintf(definition,"sqrt(1.0+(<%s>^2+<%s>^2)/(299792458*%e)^2)",px,pz,particle->mass);
            }
            // Invalid momentum dimension
            else
            {
                cerr << " The gamma expression can not be created for such a momentum dimension: " << particle->numDimsMomenta << endl;
            }

            e1->SetDefinition(definition);
            // Final type
            e1->SetType(Expression::ScalarMeshVar);
            // Units
            //e1->hasUnits = true;
            //e1->units = "";
            // Expression is visible to users
            e1->SetHidden(false);
            // Add expression to the list of metadata
            md->AddExpression(e1);
        }
    }




    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = YOU_MUST_DECIDE;
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
    //

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataSet *
avtOpenPMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{

    cerr << "avtOpenPMDFileFormat::GetMesh(timestate=" << timestate << ",domain=" << domain << ")" << endl;

    int             ndims;
    int             dims[3];
    int             i,j,k,l;
    int             err;
    int             id;
    int             nnodes;
    int             nmodes;
    char            bufferMeshName[128];
    char            bufferDataSetName[128];
    float           factor;
    float           r,theta,dtheta;
    vtkFloatArray*  coords[3];

    // ________________________________________________________
    // FIELDS

    // We look for the corresponding mesh of name meshname in the vector of fields

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timestate].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        // Current field meshname
        strcpy(bufferMeshName,"Fields/");
        strcat(bufferMeshName,field->name);
        strcat(bufferMeshName,"_mesh");

        // We have found the corresponding mesh in the vector of fields
        if (strcmp(meshname, bufferMeshName) == 0)
        {

            if (strcmp(field->geometry,"cartesian")==0)
            {

                cerr << "Read mesh: " << bufferMeshName << ", " << field->geometry << endl;

                // Read the ndims and number of X,Y,Z nodes from file.
                ndims = field->ndims;
                // 3D
                if (ndims==3)
                {
                    // Treatment of the file in parallel
                    if (this->parallel)
                    {

                        // Structure to store the block properties
                        fieldBlockStruct fieldBlock;

                        // We get the block properties
                        err = field->GetBlockProperties(4, domain , &fieldBlock);

                        cerr    << "fieldBlock.minNode[0]: " << fieldBlock.minNode[0] 
                                << " " << fieldBlock.nbNodes[0] 
                                << " " << fieldBlock.maxNode[0] << endl;

                        cerr    << "fieldBlock.minNode[1]: " << fieldBlock.minNode[1] 
                                << " " << fieldBlock.nbNodes[1] 
                                << " " << fieldBlock.maxNode[1] << endl;
                                
                        cerr << "fieldBlock.minNode[2]: " << fieldBlock.minNode[2] << " " << fieldBlock.nbNodes[2] << " " << fieldBlock.maxNode[2] << endl;

                        dims[0] = fieldBlock.nbNodes[2];
                        dims[1] = fieldBlock.nbNodes[1];
                        dims[2] = fieldBlock.nbNodes[0];

                        // Read the X coordinates from the file.
                        coords[0] = vtkFloatArray::New();
                        coords[0]->SetNumberOfTuples(dims[0]);
                        float *xarray = (float *)coords[0]->GetVoidPointer(0);
                        for(i=fieldBlock.minNode[2];i<=fieldBlock.maxNode[2];i++)
                        {
                            xarray[i - fieldBlock.minNode[2]] = ((i+field->gridPosition[2])*field->gridSpacing[2] + field->gridGlobalOffset[2])*field->gridUnitSI;
                        }

                        // Read the Y coordinates from the file.
                        coords[1] = vtkFloatArray::New();
                        coords[1]->SetNumberOfTuples(dims[1]);
                        float *yarray = (float *)coords[1]->GetVoidPointer(0);
                        for(i=fieldBlock.minNode[1];i<=fieldBlock.maxNode[1];i++)
                        {
                            yarray[i - fieldBlock.minNode[1]] = ((i+field->gridPosition[1])*field->gridSpacing[1] + field->gridGlobalOffset[1])*field->gridUnitSI;
                        }

                        // Read the Z coordinates from the file.
                        coords[2] = vtkFloatArray::New();
                        coords[2]->SetNumberOfTuples(dims[2]);
                        float *zarray = (float *)coords[2]->GetVoidPointer(0);
                        for(i=fieldBlock.minNode[0];i<=fieldBlock.maxNode[0];i++)
                        {
                            zarray[i - fieldBlock.minNode[0]] = ((i+field->gridPosition[0])*field->gridSpacing[0] + field->gridGlobalOffset[0])*field->gridUnitSI;
                        }

                    }
                    // Only one processor
                    else
                    {
                        dims[0] = field->nbNodes[2];
                        dims[1] = field->nbNodes[1];
                        dims[2] = field->nbNodes[0];

                        // Read the X coordinates from the file.
                        coords[0] = vtkFloatArray::New();
                        coords[0]->SetNumberOfTuples(dims[0]);
                        float *xarray = (float *)coords[0]->GetVoidPointer(0);
                        for(i=0;i<dims[0];i++)
                        {
                            xarray[i] = ((i+field->gridPosition[2])*field->gridSpacing[2] + field->gridGlobalOffset[2])*field->gridUnitSI;
                        }

                        // Read the Y coordinates from the file.
                        coords[1] = vtkFloatArray::New();
                        coords[1]->SetNumberOfTuples(dims[1]);
                        float *yarray = (float *)coords[1]->GetVoidPointer(0);
                        for(i=0;i<dims[1];i++)
                        {
                            yarray[i] = ((i+field->gridPosition[1])*field->gridSpacing[1] + field->gridGlobalOffset[1])*field->gridUnitSI;
                        }

                        // Read the Z coordinates from the file.
                        coords[2] = vtkFloatArray::New();
                        coords[2]->SetNumberOfTuples(dims[2]);
                        float *zarray = (float *)coords[2]->GetVoidPointer(0);
                        for(i=0;i<dims[2];i++)
                        {
                            zarray[i] = ((i+field->gridPosition[0])*field->gridSpacing[0] + field->gridGlobalOffset[0])*field->gridUnitSI;
                        }
                    }

                }
                // 2D
                else if (ndims==2)
                {

                    dims[0] = field->nbNodes[1];
                    dims[1] = field->nbNodes[0];
                    dims[2] = 1;

                    // Read the X coordinates from the file.
                    coords[0] = vtkFloatArray::New();
                    coords[0]->SetNumberOfTuples(field->nbNodes[1]);
                    float *xarray = (float *)coords[0]->GetVoidPointer(0);
                    for(i=0;i<field->nbNodes[1];i++)
                    {
                        xarray[i] = ((i+field->gridPosition[1])*field->gridSpacing[1] + field->gridGlobalOffset[1])*field->gridUnitSI;
                    }

                    // Read the Y coordinates from the file.
                    coords[1] = vtkFloatArray::New();
                    coords[1]->SetNumberOfTuples(field->nbNodes[0]);
                    float *yarray = (float *)coords[1]->GetVoidPointer(0);
                    for(i=0;i<field->nbNodes[0];i++)
                    {
                        yarray[i] = ((i+field->gridPosition[0])*field->gridSpacing[0] + field->gridGlobalOffset[0])*field->gridUnitSI;
                    }

                    // No Z coordinates
                    coords[2] = vtkFloatArray::New();
                    coords[2]->SetNumberOfTuples(1);
                    coords[2]->SetComponent(0, 0, 0.);
                }
                // No recognized dimension
                else
                {
                    cerr << " Dimension of this field dataset is not recognized: " << ndims << endl;
                }

                // Create the vtkRectilinearGrid object and set its dimensions
                // and coordinates.         
                vtkRectilinearGrid *grid = vtkRectilinearGrid::New();
                grid->SetDimensions(dims);
                grid->SetXCoordinates(coords[0]);
                coords[0]->Delete();
                grid->SetYCoordinates(coords[1]);
                coords[1]->Delete();
                grid->SetZCoordinates(coords[2]);
                coords[2]->Delete();  

                // We return the generated grid
                return grid;
            }
            else if (strcmp(field->geometry,"thetaMode")==0)
            {

                cerr << "Read mesh: " << bufferMeshName << ", " << field->geometry << endl;

                // Read the ndims and number of X,Y,Z nodes from file.
                ndims = field->ndims;
                dims[0] = field->nbNodes[2]; // z direction 
                dims[1] = field->nbNodes[1]; // r direction
                dims[2] = 10; // Theta direction

                cerr << dims[0] << " " << dims[1] << " " << dims[2] << endl;

                // Total number of nodes
                nnodes = dims[0] * dims[1] * dims[2];
                // Number of modes
                nmodes = field->nbNodes[0];

                // Read the X coordinates from the file.
                float *xarray = new float[nnodes];
                float *yarray = new float[nnodes];
                float *zarray = new float[nnodes];

                dtheta = 2*3.14159265359/(dims[2]-1);

                // Build xarray,yarray,zarray
                for(k = 0; k < dims[2]; ++k)
                for(j = 0; j < dims[1]; ++j)
                for(i = 0; i < dims[0]; ++i)
                {
                    // Absolute index
                    l = i + j*dims[0] + k*dims[0]*dims[1];
                    // Theta angle
                    theta = k*dtheta;
                    // Radius
                    r = (j*field->gridSpacing[0] + field->gridGlobalOffset[0])*field->unitSI;
                    // Position of the point
                    xarray[l] = (i*field->gridSpacing[1] + field->gridGlobalOffset[1])*field->gridUnitSI;
                    yarray[l] = (r*cos(theta));
                    zarray[l] = (r*sin(theta));
                }

                // Create the vtkStructuredGrid and vtkPoints objects.
                vtkStructuredGrid *sgrid = vtkStructuredGrid::New();
                vtkPoints *points = vtkPoints::New();
                sgrid->SetPoints(points);
                sgrid->SetDimensions(dims);
                points->Delete();
                points->SetNumberOfPoints(nnodes);               

                // Copy the coordinate values into the vtkPoints object.
                float *pts = (float *) points->GetVoidPointer(0);
                float *xc = xarray;
                float *yc = yarray;
                float *zc = zarray;
                if(ndims == 3)
                {
                    for(k = 0; k < dims[2]; ++k)
                    for(j = 0; j < dims[1]; ++j)
                    for(i = 0; i < dims[0]; ++i)
                    {
                        *pts++ = *xc++;
                        *pts++ = *yc++;
                        *pts++ = *zc++;
                    }
                }
                else if(ndims == 2)
                {
                    for(j = 0; j < dims[1]; ++j)
                    for(i = 0; i < dims[0]; ++i)
                    {
                        *pts++ = *xc++;
                        *pts++ = *yc++;
                        *pts++ = 0.;
                    }
                }
                // Delete temporary arrays.
                delete [] xarray;
                delete [] yarray;
                delete [] zarray;
                return sgrid;
            }
        }
    }

    // ________________________________________________________
    // PARTICLES

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Mesh name
        strcpy(bufferMeshName,"Particles/");
        strcat(bufferMeshName,particle->name);
        strcat(bufferMeshName,"/position_mesh");

        if (strcmp(meshname, bufferMeshName) == 0)
        {

            cerr << "Read mesh: " << bufferMeshName << endl;

            // Read the ndims and number of nodes from file.
            ndims = particle->numDimsPositions;
            nnodes = particle->numParticles;

            // Sanity check
            if ((ndims <= 0)||(ndims >3))
            {
                cerr << "The number of position datasets is invalid: " << ndims << endl;
            }

            // Read the X coordinates from the file.
            float *xarray = new float[nnodes];

            // Dataset Id
            id = particle->positionsId[2];

            // Dataset path
            strcpy(bufferDataSetName,particle->scalarDataSets[id].path);

            // Multiplication factor
            factor = particle->scalarDataSets[id].unitSI;

            // Read the dataset
            cerr << "Read dataset: " << bufferDataSetName << endl;
            openPMDFile.ReadScalarDataSet(xarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);

            // Read the Y coordinates from the file.
            float *yarray = new float[nnodes];   

            // Dataset Id
            id = particle->positionsId[1];

            // Dataset path
            strcpy(bufferDataSetName,particle->scalarDataSets[id].path);    

            // Multiplication factor
            factor = particle->scalarDataSets[id].unitSI;

            // Read the dataset
            cerr << "Read dataset: " << bufferDataSetName << endl;
            openPMDFile.ReadScalarDataSet(yarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);

            float *zarray = 0;
            if (ndims>2) 
            {
                // Read the Z coordinates from the file.
                zarray = new float[nnodes];   

                // Dataset Id
                id = particle->positionsId[0];

                // Dataset path
                strcpy(bufferDataSetName,particle->scalarDataSets[id].path);         

                // Multiplication factor
                factor = particle->scalarDataSets[id].unitSI;

                // Read the dataset
                cerr << "Read dataset: " << bufferDataSetName << endl;
                openPMDFile.ReadScalarDataSet(zarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);
            }

            // Create the vtkPoints object and copy points into it.
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(nnodes);
            float *pts = (float *) points->GetVoidPointer(0);
            float *xc = xarray;
            float *yc = yarray;
            float *zc = zarray;
            if(ndims == 3)
            {
                for(int i = 0; i < nnodes; ++i)
                {
                    *pts++ = *xc++;
                    *pts++ = *yc++;
                    *pts++ = *zc++;
                }
            }
            else if(ndims == 2)
            {
                for(int i = 0; i < nnodes; ++i)
                {
                    *pts++ = *xc++;
                    *pts++ = *yc++;
                    *pts++ = 0.;
                }
            }            
            
            // Create a vtkUnstructuredGrid to contain the point cells.
            vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
            ugrid->SetPoints(points);
            points->Delete();
            ugrid->Allocate(nnodes);
            vtkIdType onevertex;
            for(int i = 0; i < nnodes; ++i)
            {
                onevertex = i;
                ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex);
            }

            // Delete temporary arrays.
            delete [] xarray;
            delete [] yarray;
            delete [] zarray;
            return ugrid;

        }

    }

    // No mesh name that we recognize.
    EXCEPTION1(InvalidVariableException, meshname);
    return 0;
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataArray *
avtOpenPMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::GetVar "
        << timestate << "" << domain << " " << varname << endl;
#endif

    int     i,j,k,l,m;
    int     numValues;
    int     err;
    int     dims[3];
    char    buffer[128];
    hid_t   datasetId;
    hid_t   datasetType;
    hid_t   datasetSpace;
    hsize_t datasetStorageSize;
    int     ndims;
    float * array;
    float   factor;
    bool    varFound;

    // ________________________________________________________
    // FIELDS
    // This part get the scalar datasets from the fields

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timestate].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);

        // Determine which scalar dataset to return.
        if (strcmp(varname, buffer) == 0)
        {

            if (strcmp(field->geometry,"cartesian")==0)
            {

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray * vtkArray = vtkFloatArray::New();

                // We treat the file in parallel by reading the scalar dataset by block
                if (parallel)
                {

                    // Structure to store the block properties
                    fieldBlockStruct fieldBlock;

                    // We get the block properties
                    err = field->GetBlockProperties(4, domain , &fieldBlock);

                    // Number of nodes
                    numValues = fieldBlock.nbTotalNodes;

                    // Factor for SI units
                    factor = field->unitSI;

                    // Allocate the return vtkFloatArray object
                    vtkArray->SetNumberOfTuples(numValues);
                    float *data = (float *)vtkArray->GetVoidPointer(0);

#ifdef VERBOSE
                    cerr << " Reading dataset: " << field->datasetPath << endl;
#endif

                    // Reading of the dataset block
                    err = openPMDFile.ReadFieldScalarBlock(data,&factor,H5T_FLOAT,&fieldBlock);

                }
                // Sequential reading of the dataset
                else
                {
                    // Number of values
                    numValues = field->GetNumValues();
                    // Factor for SI units
                    factor = field->unitSI;

                    // Allocate the return vtkFloatArray object
                    vtkArray->SetNumberOfTuples(numValues);
                    float *data = (float *)vtkArray->GetVoidPointer(0);

#ifdef VERBOSE
                    cerr << " Reading dataset: " << field->datasetPath << endl;
#endif

                    // Reading of the dataset
                    err = openPMDFile.ReadScalarDataSet(data,numValues,&factor,H5T_FLOAT,field->datasetPath);
                }


                // If no error, we return the array
                if (err>=0)
                {
                    return vtkArray;
                }

            }
            else if (strcmp(field->geometry,"thetaMode")==0)
            {
                // Dimensions
                dims[0] = field->nbNodes[2]; // z direction 
                dims[1] = field->nbNodes[1]; // r direction
                dims[2] = 10;               // Theta direction

                // Factor for SI units
                factor = field->unitSI;
                cerr << " Factor: " << factor << endl;

                // Total number of Values
                numValues = dims[0]*dims[1]*dims[2];

                // Allocate the dataset array with the different modes
                float *dataSetArray = new float(dims[1]*dims[0]*3);

                cerr << " Reading dataset: " << field->datasetPath << endl;

                // Reading of the dataset
                err = openPMDFile.ReadScalarDataSet(dataSetArray,dims[1]*dims[0]*3,&factor,H5T_FLOAT,field->datasetPath);

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray * vtkArray = vtkFloatArray::New();
                vtkArray->SetNumberOfTuples(numValues);
                float *data = (float *)vtkArray->GetVoidPointer(0);

                // Treatment of the data

                // We first build the mode 0
                cerr << " Build mode 0" << endl;
                for(k = 0; k < dims[2]; ++k) // Loop theta
                for(j = 0; j < dims[1]; ++j) // Loop r
                for(i = 0; i < dims[0]; ++i) // Loop z
                {
                    // Absolute indexes
                    l = i + j*dims[0];
                    m = l + k*dims[0]*dims[1];

                    // Update of data
                    data[m] = dataSetArray[l];

                    cerr << "m: " << m << "/" << numValues-1 << " l: " << l << "/" << dims[1]*dims[0]-1 << " data[m]: " << data[m] << " dataSetArray[l]: "<< dataSetArray[l] << endl;
                }             

                // If no error, we return the array
                if (err>=0)
                {
                    cerr << " Return vtkArray" << endl;
                    usleep(1000000);
                    return vtkArray;
                }

                // Delete temporary arrays
                //delete dataSetArray; 
                //delete data;

            }        

        }
    }

    // ________________________________________________________
    // PARTICLES
    // This part gets the scalar datasets from the particles

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Iteration over the scalar datasets
        for (i=0;i<particle->scalarDataSets.size();i++)
        {

            strcpy(buffer,"Particles/");
            strcat(buffer,particle->scalarDataSets[i].name);

            // Determine which scalar dataset to return.
            if (strcmp(varname, buffer) == 0)
            {

                // Number of particles
                numValues = particle->numParticles;
                // multiplication factor for SI units
                factor=particle->scalarDataSets[i].unitSI;

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray * vtkArray = vtkFloatArray::New();
                vtkArray->SetNumberOfTuples(numValues);
                float *data = (float *)vtkArray->GetVoidPointer(0);

                cerr << " Dataset path: " << particle->scalarDataSets[i].path << endl;

                // Reading of the dataset
                err = openPMDFile.ReadScalarDataSet(data,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[i].path);

                // If no error, we return the array
                if (err>=0)
                {
                    return vtkArray;
                }

            }
        }

    }
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.

    EXCEPTION1(InvalidVariableException, varname);

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //

    return 0;

}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataArray *
avtOpenPMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
#ifdef VERBOSE
    cerr << "avtOpenPMDFileFormat::GetVectorVar"  << timestate << " " << varname << endl;
#endif

    int     i;
    int     err;
    int     scalarDataSetId;
    int     numValues;
    int     numComponents;
    char    buffer[128];
    float   factor;

    // ________________________________________________________
    // PARTICLES
    // This part get the scalar datasets from the particles

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Iteration over the vector datasets
        for (i=0;i<particle->vectorDataSets.size();i++)
        {

            // Current dataset name to be compared with varname
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->vectorDataSets[i].name);

            // If we find the correct dataset of name varname...
            if (strcmp(varname, buffer) == 0)
            {
                // Number of particles for this dataset
                numValues = particle->numParticles;
                // Number of components (2D or 3D)
                numComponents = particle->numDimsMomenta;

                // Read component 1 from the file.
                float *comp1 = new float[numValues];
                // Reading of the first dataset
                scalarDataSetId = particle->vectorDataSets[i].dataSetId[2];
                // Multiplication factor
                factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                // Reading of the dataset     
                err = openPMDFile.ReadScalarDataSet(comp1,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 

                // Read component 2 from the file.
                float *comp2 = new float[numValues];
                // Reading of the first dataset
                scalarDataSetId = particle->vectorDataSets[i].dataSetId[1];
                // Multiplication factor
                factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                // Reading of the dataset                
                err = openPMDFile.ReadScalarDataSet(comp2,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 

                float *comp3;
                if(numComponents > 2)
                {
                    // Read component 3 from the file.
                    comp3 = new float[numValues];
                    // Reading of the first dataset
                    scalarDataSetId = particle->vectorDataSets[i].dataSetId[0];
                    // Multiplication factor
                    factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                    // Reading of the dataset                      
                    err = openPMDFile.ReadScalarDataSet(comp3,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 
                }

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray *arr = vtkFloatArray::New();
                arr->SetNumberOfComponents(3);
                arr->SetNumberOfTuples(numValues);
                float *data = (float *)arr->GetVoidPointer(0);
                float *c1 = comp1;
                float *c2 = comp2;
                float *c3 = comp3;
                if(numComponents == 3)
                {
                    for(int i = 0; i < numValues; ++i)
                    {
                        *data++ = *c1++;
                        *data++ = *c2++;
                        *data++ = *c3++;
                    }
                }
                else if(numComponents == 2)
                {
                    for(int i = 0; i < numValues; ++i)
                    {
                        *data++ = *c1++;
                        *data++ = *c2++;
                        *data++ = 0.;
                    }
                }
                else
                {
                    delete [] comp1;
                    delete [] comp2;
                    delete [] comp3;
                    arr->Delete();
                    EXCEPTION1(InvalidVariableException, varname);
                }
                // Delete temporary arrays.
                delete [] comp1;
                delete [] comp2;
                delete [] comp3;
                return arr;
            }
        }
    }


    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.

    EXCEPTION1(InvalidVariableException, varname);


    return 0;

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}

