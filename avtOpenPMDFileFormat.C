/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtOpenPMDFileFormat.C                           //
// ************************************************************************* //

#include <avtOpenPMDFileFormat.h>

#include <vector>
#include <stdlib.h>
#include <stdio.h>
#include <stdio.h>
#include <iostream>
#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkVertex.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>
#include <InvalidFilesException.h>
#include <InvalidTimeStepException.h>
#include <InvalidDBTypeException.h>

using     std::string;


// ****************************************************************************
//  Method: avtOpenPMDFileFormat constructor
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

avtOpenPMDFileFormat::avtOpenPMDFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    cerr << "avtOpenPMDFileFormat::avtOpenPMDFileFormat "  << filename << endl;

    // Boolean to check that the initialization has been done
    this->initialized = false;
}


// ****************************************************************************
//  Method: ~avtOpenPMDFileFormat Destructor
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
avtOpenPMDFileFormat::~avtOpenPMDFileFormat()
{
    cerr << "avtOpenPMDFileFormat::~avtOpenPMDFileFormat" << endl;
}


// ****************************************************************************
//  Method: Initialize
//
//  Initialization: the OpenPMD file is read and analyze
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::Initialize()
{
    cerr << "avtOpenPMDFileFormat::Initialize" << endl;

    if(!this->initialized)
    {
        // Open the OpenPMD file
        openPMDFile.OpenFile(filename);

        // Scan the iterations
        openPMDFile.ScanIterations();

        // For each iteration, scan the fields
        openPMDFile.ScanFields();

        // For each iteration, scan the particle groups
        openPMDFile.ScanParticles();

        this->initialized = true;
    }
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

int
avtOpenPMDFileFormat::GetNTimesteps(void)
{
    cerr << "avtOpenPMDFileFormat::GetNTimesteps" << endl;

    // If not initialized, initialize...
    if(!this->initialized)
        this->Initialize();

    // Get the number of time steps read in the OpenPMD file
    int NTimesteps = this->openPMDFile.GetNumberIterations();

    return NTimesteps;
    //return 1;
}

// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetCycles
//
//  Purpose:
//      Get all cycles in the OpenPMD file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::GetCycles(std::vector<int> &cycles)
{

    int cycle;

    // Shortcut pointer to the vector iterations
    vector<PMDIteration> * iterations = &(openPMDFile.iterations);

    // Loop over the iterations
    for (std::vector<PMDIteration>::iterator it = iterations->begin() ; it != iterations->end(); ++it)
    {
        cycle = atoi(it->name);

        // Store the cycles in the vector.
        cycles.push_back(cycle);
    }

}

// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetTime
//
//  Purpose:
//      Get all times in the OpenPMD file.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************
void
avtOpenPMDFileFormat::GetTimes(std::vector<double> &times)
{
    // Shortcut pointer to the vector iterations
    vector<PMDIteration> * iterations = &(openPMDFile.iterations);

    // Loop over the iterations
    for (std::vector<PMDIteration>::iterator it = iterations->begin() ; it != iterations->end(); ++it)
    {
        // Store the times in the vector.
        times.push_back(it->time*it->timeUnitSI);
    }
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

void
avtOpenPMDFileFormat::FreeUpResources(void)
{
    cerr << "avtOpenPMDFileFormat::FreeUpResources" << endl;
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

void
avtOpenPMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    cerr << "avtOpenPMDFileFormat::PopulateDatabaseMetaData" << endl;

    int i;
    char buffer[128];
    char bufferMeshName[128];

    // ________________________________________________________
    // FIELDS

    // Creation of the meshes and the scalars from the vector of field objects

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timeState].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        // We first create a new mesh for the current field
        // Each field has its own mesh
        avtMeshMetaData *mmd = new avtMeshMetaData;
        // Create the mesh name
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        strcat(buffer,"_mesh");
        mmd->name = buffer;
        // Spatial dimension
        mmd->spatialDimension = field->ndims;
        // Topological Dimension
        mmd->topologicalDimension = field->ndims;
        // Mesh type
        if (strstr(field->geometry,"cartesian")==0)
        {
            mmd->meshType = AVT_RECTILINEAR_MESH;
        }
        // Number of blocks
        mmd->numBlocks = 1;
        // Add mesh
        md->Add(mmd);

        // Then we create a scalar for the current field
        avtScalarMetaData *smd = new avtScalarMetaData;
        // Create the variable name
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        smd->name = buffer;
        // And select the right mesh
        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);
        strcat(buffer,"_mesh");
        smd->meshName = buffer;
        // Node or cell centered
        smd->centering = AVT_NODECENT;
        // Units
        smd->hasUnits = true;
        smd->units = field->unitsLabel;
        // Add the scalars
        md->Add(smd);

    }  

    // ________________________________________________________
    // PARTICLES

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timeState].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {

        // Add a point mesh to the metadata for the particles
        avtMeshMetaData *mmd = new avtMeshMetaData;
        // Mesh name
        strcpy(bufferMeshName,"Particles/");
        strcat(bufferMeshName,particle->name);
        strcat(bufferMeshName,"/position_mesh");
        mmd->name = bufferMeshName;
        // Spatial and topological dimension
        mmd->spatialDimension = 3;
        mmd->topologicalDimension = 0;
        // Type of mesh, here point mesh
        mmd->meshType = AVT_POINT_MESH;
        mmd->numBlocks = 1;
        md->Add(mmd);

        // We create a scalar metadata for each scalar in scalarDataSets
        for (i=0;i<particle->GetNumScalarDatasets();i++)
        {

            // Then we create a scalar for the current field
            avtScalarMetaData *smd = new avtScalarMetaData;
            // Create the scalar name
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->scalarDataSets[i].name);
            smd->name = buffer;

            // And select the right mesh
            smd->meshName = bufferMeshName;
            // Node or cell centered
            smd->centering = AVT_NODECENT;

            // Units
            smd->hasUnits = true;
            smd->units = particle->scalarDataSets[i].unitLabel;
            // Add the scalars
            md->Add(smd);

        }

        // We create a vector metadata for each scalar in scalarDataSets
        for (i=0;i<particle->GetNumVectorDatasets();i++)
        {
            avtVectorMetaData *vmd = new avtVectorMetaData;
            // Create the scalar name
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->vectorDataSets[i].name);
            vmd->name = buffer;
            // And select the right mesh
            vmd->meshName = bufferMeshName;
            // Node or cell centered
            vmd->centering = AVT_ZONECENT;
            // Units
            vmd->hasUnits = true;
            vmd->units = particle->vectorDataSets[i].unitLabel;
            // Vector dimension
            vmd->varDim = 3;
            md->Add(vmd);
        }  

        if (particle->momentumAvailable)
        {
            // Particle Expressions
            Expression *e1 = new Expression;
            // Create the name
            strcpy(buffer,"Particles/");  
            strcat(buffer,particle->name);
            strcat(buffer,"/gamma");
            e1->SetName(buffer);

            // Create the definition
            char px[128], py[128], pz[128];

            sprintf(px,"Particles/%s/momentum/x",particle->name);
            sprintf(py,"Particles/%s/momentum/y",particle->name);
            sprintf(pz,"Particles/%s/momentum/z",particle->name);        

            char definition[256];
            sprintf(definition,"sqrt(1.0+<%s>^2+<%s>^2+<%s>^2/(299792458*%e)^2)",px,py,pz,particle->mass);

            e1->SetDefinition(definition);
            // Final type
            e1->SetType(Expression::ScalarMeshVar);
            // Units
            //e1->hasUnits = true;
            //e1->units = "";
            // Expression is visible to users
            e1->SetHidden(false);
            // Add expression to the list of metadata
            md->AddExpression(e1);
        }
    }




    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = YOU_MUST_DECIDE;
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
    //

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataSet *
avtOpenPMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{

    cerr << "avtOpenPMDFileFormat::GetMesh" << endl;

    int             ndims;
    int             dims[3];
    int             i;
    int             id;
    int             nnodes;
    char            bufferMeshName[128];
    char            bufferDataSetName[128];
    float           factor;
    vtkFloatArray*  coords[3];

    // ________________________________________________________
    // FIELDS

    // We look for the corresponding mesh of name meshname in the vector of fields

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timestate].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        // Current field meshname
        strcpy(bufferMeshName,"Fields/");
        strcat(bufferMeshName,field->name);
        strcat(bufferMeshName,"_mesh");

        // We have found the corresponding mesh in the vector of fields
        if (strcmp(meshname, bufferMeshName) == 0)
        {
 
            cerr << "Read mesh: " << bufferMeshName << endl;

            // Read the ndims and number of X,Y,Z nodes from file.
            ndims = field->ndims;
            dims[0] = field->nbNodes[2];
            dims[1] = field->nbNodes[1];
            dims[2] = field->nbNodes[0];

            // Read the X coordinates from the file.
            coords[0] = vtkFloatArray::New();
            coords[0]->SetNumberOfTuples(dims[0]);
            float *xarray = (float *)coords[0]->GetVoidPointer(0);
            for(i=0;i<dims[0];i++)
            {
                xarray[i] = ((i+field->gridPosition[2])*field->gridSpacing[2] + field->gridGlobalOffset[2])*field->unitSI;
            }

            // Read the Y coordinates from the file.
            coords[1] = vtkFloatArray::New();
            coords[1]->SetNumberOfTuples(dims[1]);
            float *yarray = (float *)coords[1]->GetVoidPointer(0);
            for(i=0;i<dims[1];i++)
            {
                yarray[i] = ((i+field->gridPosition[1])*field->gridSpacing[1] + field->gridGlobalOffset[1])*field->unitSI;
            }

            // Read the Z coordinates from the file.
            coords[2] = vtkFloatArray::New();
            if(ndims > 2)
            {
                coords[2]->SetNumberOfTuples(dims[2]);
                float *zarray = (float *)coords[2]->GetVoidPointer(0);
                for(i=0;i<dims[2];i++)
                {
                    zarray[i] = ((i+field->gridPosition[0])*field->gridSpacing[0] + field->gridGlobalOffset[0])*field->unitSI;
                }
            }
            else
            {
            coords[2]->SetNumberOfTuples(1);
            coords[2]->SetComponent(0, 0, 0.);
            }

            
            // Create the vtkRectilinearGrid object and set its dimensions
            // and coordinates.         
            vtkRectilinearGrid *grid = vtkRectilinearGrid::New();
            grid->SetDimensions(dims);
            grid->SetXCoordinates(coords[0]);
            coords[0]->Delete();
            grid->SetYCoordinates(coords[1]);
            coords[1]->Delete();
            grid->SetZCoordinates(coords[2]);
            coords[2]->Delete();  

            // We return the generated grid
            return grid;
        }
    }

    // ________________________________________________________
    // PARTICLES

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Mesh name
        strcpy(bufferMeshName,"Particles/");
        strcat(bufferMeshName,particle->name);
        strcat(bufferMeshName,"/position_mesh");

        if (strcmp(meshname, bufferMeshName) == 0)
        {

            cerr << "Read mesh: " << bufferMeshName << endl;

            // Read the ndims and number of nodes from file.
            ndims = 3;
            nnodes = particle->numParticles;

            // Read the X coordinates from the file.
            float *xarray = new float[nnodes];

            // Dataset Id
            id = particle->positionsId[2];

            // Dataset path
            strcpy(bufferDataSetName,particle->scalarDataSets[id].path);

            // Multiplication factor
            factor = particle->scalarDataSets[id].unitSI;

            // Read the dataset
            cerr << "Read dataset: " << bufferDataSetName << endl;
            openPMDFile.ReadScalarDataSet(xarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);

            // Read the Y coordinates from the file.
            float *yarray = new float[nnodes];   

            // Dataset Id
            id = particle->positionsId[1];

            // Dataset path
            strcpy(bufferDataSetName,particle->scalarDataSets[id].path);    

            // Multiplication factor
            factor = particle->scalarDataSets[id].unitSI;

            // Read the dataset
            cerr << "Read dataset: " << bufferDataSetName << endl;
            openPMDFile.ReadScalarDataSet(yarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);

            float *zarray = 0;
            if (ndims>2) 
            {
                // Read the Z coordinates from the file.
                zarray = new float[nnodes];   

                // Dataset Id
                id = particle->positionsId[0];

                // Dataset path
                strcpy(bufferDataSetName,particle->scalarDataSets[id].path);         

                // Multiplication factor
                factor = particle->scalarDataSets[id].unitSI;

                // Read the dataset
                cerr << "Read dataset: " << bufferDataSetName << endl;
                openPMDFile.ReadScalarDataSet(zarray,nnodes,&factor,H5T_FLOAT,bufferDataSetName);
            }

            // Create the vtkPoints object and copy points into it.
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(nnodes);
            float *pts = (float *) points->GetVoidPointer(0);
            float *xc = xarray;
            float *yc = yarray;
            float *zc = zarray;
            if(ndims == 3)
            {
                for(int i = 0; i < nnodes; ++i)
                {
                    *pts++ = *xc++;
                    *pts++ = *yc++;
                    *pts++ = *zc++;
                }
            }
            else if(ndims == 2)
            {
                for(int i = 0; i < nnodes; ++i)
                {
                    *pts++ = *xc++;
                    *pts++ = *yc++;
                    *pts++ = 0.;
                }
            }            
            
            // Create a vtkUnstructuredGrid to contain the point cells.
            vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
            ugrid->SetPoints(points);
            points->Delete();
            ugrid->Allocate(nnodes);
            vtkIdType onevertex;
            for(int i = 0; i < nnodes; ++i)
            {
                onevertex = i;
                ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex);
            }

            // Delete temporary arrays.
            delete [] xarray;
            delete [] yarray;
            delete [] zarray;
            return ugrid;

        }

    }

    // No mesh name that we recognize.
    EXCEPTION1(InvalidVariableException, meshname);
    return 0;
}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataArray *
avtOpenPMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    cerr << "avtOpenPMDFileFormat::GetVar "
        << timestate << " " << varname << endl;

    int     i;
    int     numValues;
    int     err;
    char    buffer[128];
    hid_t   datasetId;
    hid_t   datasetType;
    hid_t   datasetSpace;
    hsize_t datasetStorageSize;
    int     ndims;
    float * array;
    float   factor;
    bool    varFound;

    // ________________________________________________________
    // FIELDS
    // This part get the scalar datasets from the fields

    // Shortcut pointer to the fields
    vector<PMDField> * fields = &(openPMDFile.iterations[timestate].fields);

    // Iteration over the fields
    for (std::vector<PMDField>::iterator field = fields->begin() ; field != fields->end(); ++field)
    {

        strcpy(buffer,"Fields/");
        strcat(buffer,field->name);

        // Determine which scalar dataset to return.
        if (strcmp(varname, buffer) == 0)
        {

            // Number of values
            numValues = field->GetNumValues();
            // Factor for SI units
            factor = field->gridUnitSI;

            // Allocate the return vtkFloatArray object. Note that
            // you can use vtkFloatArray, vtkDoubleArray,
            // vtkUnsignedCharArray, vtkIntArray, etc.
            vtkFloatArray * vtkArray = vtkFloatArray::New();
            vtkArray->SetNumberOfTuples(numValues);
            float *data = (float *)vtkArray->GetVoidPointer(0);

            cerr << " Dataset path: " << field->datasetPath << endl;

            // Reading of the dataset
            err = openPMDFile.ReadScalarDataSet(data,numValues,&factor,H5T_FLOAT,field->datasetPath);

            // If no error, we return the array
            if (err>=0)
            {
                return vtkArray;
            }        

        }
    }

    // ________________________________________________________
    // PARTICLES
    // This part gets the scalar datasets from the particles

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Iteration over the scalar datasets
        for (i=0;i<particle->scalarDataSets.size();i++)
        {

            strcpy(buffer,"Particles/");
            strcat(buffer,particle->scalarDataSets[i].name);

            // Determine which scalar dataset to return.
            if (strcmp(varname, buffer) == 0)
            {

                // Number of particles
                numValues = particle->numParticles;
                // multiplication factor for SI units
                factor=particle->scalarDataSets[i].unitSI;

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray * vtkArray = vtkFloatArray::New();
                vtkArray->SetNumberOfTuples(numValues);
                float *data = (float *)vtkArray->GetVoidPointer(0);

                cerr << " Dataset path: " << particle->scalarDataSets[i].path << endl;

                // Reading of the dataset
                err = openPMDFile.ReadScalarDataSet(data,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[i].path);

                // If no error, we return the array
                if (err>=0)
                {
                    return vtkArray;
                }

            }
        }

    }
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.

    EXCEPTION1(InvalidVariableException, varname);

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //

    return 0;

}


// ****************************************************************************
//  Method: avtOpenPMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: mlobet -- generated by xml2avt
//  Creation:   Tue Oct 18 11:49:37 PDT 2016
//
// ****************************************************************************

vtkDataArray *
avtOpenPMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{

    cerr << "avtOpenPMDFileFormat::GetVectorVar"  << timestate << " " << varname << endl;

    int     i;
    int     err;
    int     scalarDataSetId;
    int     numValues;
    int     numComponents;
    char    buffer[128];
    float   factor;

    // ________________________________________________________
    // PARTICLES
    // This part get the scalar datasets from the particles

    // Shortcut pointer to the particles
    vector<PMDParticle> * particles = &(openPMDFile.iterations[timestate].particles);

    // Iteration over the particles
    for (std::vector<PMDParticle>::iterator particle = particles->begin() ; particle != particles->end(); ++particle)
    {
        // Iteration over the vector datasets
        for (i=0;i<particle->vectorDataSets.size();i++)
        {

            // Current dataset name to be compared with varname
            strcpy(buffer,"Particles/");
            strcat(buffer,particle->vectorDataSets[i].name);

            // If we find the correct dataset of name varname...
            if (strcmp(varname, buffer) == 0)
            {
                // Number of particles for this dataset
                numValues = particle->numParticles;
                // Number of components (2D or 3D)
                numComponents = 3;

                // Read component 1 from the file.
                float *comp1 = new float[numValues];
                // Reading of the first dataset
                scalarDataSetId = particle->vectorDataSets[i].dataSetId[2];
                // Multiplication factor
                factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                // Reading of the dataset     
                err = openPMDFile.ReadScalarDataSet(comp1,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 

                // Read component 2 from the file.
                float *comp2 = new float[numValues];
                // Reading of the first dataset
                scalarDataSetId = particle->vectorDataSets[i].dataSetId[1];
                // Multiplication factor
                factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                // Reading of the dataset                
                err = openPMDFile.ReadScalarDataSet(comp2,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 

                float *comp3;
                if(numComponents > 2)
                {
                    // Read component 3 from the file.
                    comp3 = new float[numValues];
                    // Reading of the first dataset
                    scalarDataSetId = particle->vectorDataSets[i].dataSetId[0];
                    // Multiplication factor
                    factor = particle->scalarDataSets[scalarDataSetId].unitSI;
                    // Reading of the dataset                      
                    err = openPMDFile.ReadScalarDataSet(comp3,numValues,&factor,H5T_FLOAT,particle->scalarDataSets[scalarDataSetId].path); 
                }

                // Allocate the return vtkFloatArray object. Note that
                // you can use vtkFloatArray, vtkDoubleArray,
                // vtkUnsignedCharArray, vtkIntArray, etc.
                vtkFloatArray *arr = vtkFloatArray::New();
                arr->SetNumberOfComponents(3);
                arr->SetNumberOfTuples(numValues);
                float *data = (float *)arr->GetVoidPointer(0);
                float *c1 = comp1;
                float *c2 = comp2;
                float *c3 = comp3;
                if(numComponents == 3)
                {
                    for(int i = 0; i < numValues; ++i)
                    {
                        *data++ = *c1++;
                        *data++ = *c2++;
                        *data++ = *c3++;
                    }
                }
                else if(numComponents == 2)
                {
                    for(int i = 0; i < numValues; ++i)
                    {
                        *data++ = *c1++;
                        *data++ = *c2++;
                        *data++ = 0.;
                    }
                }
                else
                {
                    delete [] comp1;
                    delete [] comp2;
                    delete [] comp3;
                    arr->Delete();
                    EXCEPTION1(InvalidVariableException, varname);
                }
                // Delete temporary arrays.
                delete [] comp1;
                delete [] comp2;
                delete [] comp3;
                return arr;
            }
        }
    }


    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.

    EXCEPTION1(InvalidVariableException, varname);


    return 0;

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}

